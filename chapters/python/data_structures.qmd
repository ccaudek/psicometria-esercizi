---
title: "Chapter 2: Data Structures"
format:
  html:
    code-tools: true
jupyter: python3
---

::: {#exr-prob-on-general-spaces-1}
Supponiamo di dover formare una commissione di 5 psicologi su un gruppo di 20 persone (10 psicologi clinici e 10 psicologi del lavoro). Qual Ã¨ la probabilitÃ  che almeno 2 psicologi clinici siano nella commissione? Risolvi il problema usando una simulazione Monte Carlo.
:::

<button class="solution-toggle">ðŸ‘€ Visualizza la Soluzione</button>
<div class="solution">

Per calcolare questa probabilitÃ  in maniera analitica, utilizziamo la seguente uguaglianza:

$$
P(\text{almeno 2 psicologi clinici}) = 1 - P(\text{nessun psicologo clinico}) - P(\text{1 psicologo clinico}).
$$

Il numero totale di modi per selezionare 5 persone dal gruppo di 20 Ã¨ dato da:

$$
\binom{20}{5} = \frac{20!}{5!(15!)} = 15,504.
$$

Il numero di modi per avere nessun psicologo clinico nella commissione (ovvero, selezionare solo psicologi del lavoro) Ã¨:

$$
\binom{10}{0} \times \binom{10}{5} = 1 \times 252 = 252.
$$

Quindi, la probabilitÃ  di avere nessun psicologo clinico Ã¨:

$$
P(\text{nessun psicologo clinico}) = \frac{252}{15,504} \approx 0.016.
$$

Il numero di modi per avere esattamente 1 psicologo clinico nella commissione Ã¨:

$$
\binom{10}{1} \times \binom{10}{4} = 10 \times 210 = 2,100.
$$

Quindi, la probabilitÃ  di avere esattamente 1 psicologo clinico Ã¨:

$$
P(\text{1 psicologo clinico}) = \frac{2,100}{15,504} \approx 0.135.
$$

La probabilitÃ  di avere almeno 2 psicologi clinici nella commissione Ã¨ quindi:

$$
\begin{align}
P(\text{almeno 2 psicologi clinici}) &= 1 - P(\text{nessun psicologo clinico}) - P(\text{1 psicologo clinico}) \notag\\ 
&= 1 - 0.016 - 0.135 \notag\\ 
&= 0.848.\notag
\end{align}
$$

Quindi, la probabilitÃ  che almeno 2 psicologi clinici siano nella commissione Ã¨ circa 0.848.

```{python}
import numpy as np
import scipy.stats as stats
import math


# Funzione per calcolare le combinazioni
def nCk(n, k):
    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))


# Calcolo delle probabilitÃ  per il problema della commissione
total_ways = nCk(20, 5)
no_clinical = nCk(10, 0) * nCk(10, 5)
one_clinical = nCk(10, 1) * nCk(10, 4)

p_no_clinical = no_clinical / total_ways
p_one_clinical = one_clinical / total_ways

p_at_least_two_clinical = 1 - p_no_clinical - p_one_clinical

print(f"ProbabilitÃ  di almeno 2 psicologi clinici: {p_at_least_two_clinical:.3f}")
```

In maniera piÃ¹ intuitiva, possiamo risolvere il problema con una simulazione Monte Carlo.

```{python}
import random

# Numero di simulazioni
simulations = 1000000

# Numero di successi (almeno 2 psicologi clinici nella commissione)
success_count = 0

# Creiamo una lista che rappresenta il gruppo di 20 persone
# 1 rappresenta un psicologo clinico, 0 rappresenta un psicologo del lavoro
group = [1] * 10 + [0] * 10

# Simulazione Monte Carlo
for _ in range(simulations):
    # Estrai casualmente 5 persone dal gruppo
    committee = random.sample(group, 5)

    # Conta quanti psicologi clinici ci sono nella commissione
    num_clinical_psychologists = sum(committee)

    # Verifica se ci sono almeno 2 psicologi clinici
    if num_clinical_psychologists >= 2:
        success_count += 1

# Calcola la probabilitÃ 
probability = success_count / simulations

# Mostra il risultato
print(
    f"La probabilitÃ  che almeno 2 psicologi clinici siano nella commissione Ã¨: {probability:.4f}"
)
```

</div>


::: {#exr-list-manipulation-1}

Write a function that takes a list of numbers and returns a new list containing:
1. All even numbers from the original list
2. Sorted in descending order
3. With duplicates removed

Example input: `[1, 4, 2, 7, 8, 2, 3, 4, 9, 6]`
:::

<button class="solution-toggle">ðŸ‘€ Visualizza la Soluzione</button>
<div class="solution">

Here's the solution with explanation:

```{python}
def process_numbers(numbers):
    # Convert to set to remove duplicates
    # Filter for even numbers
    # Sort in descending order
    result = sorted(
        {num for num in numbers if num % 2 == 0},
        reverse=True
    )
    return result

# Test the function
test_list = [1, 4, 2, 7, 8, 2, 3, 4, 9, 6]
print(f"Original list: {test_list}")
print(f"Processed list: {process_numbers(test_list)}")
```

**Explanation:**
- We use a set comprehension to simultaneously remove duplicates and filter even numbers
- The `sorted()` function with `reverse=True` handles the descending order requirement
- This solution has O(n log n) time complexity due to the sorting operation
</div>


::: {#exr-dictionary-operations-1}
Create a function that takes a string of words and returns a dictionary where:
- Keys are the words
- Values are dictionaries containing:
  - 'length': length of the word
  - 'vowels': count of vowels in the word
  - 'palindrome': boolean indicating if the word is a palindrome

Example input: "level python noon code"
:::

<button class="solution-toggle">ðŸ‘€ Visualizza la Soluzione</button>
<div class="solution">

Here's the solution with explanation:

```{python}
def analyze_words(text):
    def count_vowels(word):
        return sum(1 for char in word.lower() if char in 'aeiou')
    
    def is_palindrome(word):
        word = word.lower()
        return word == word[::-1]
    
    words = text.split()
    result = {}
    
    for word in words:
        result[word] = {
            'length': len(word),
            'vowels': count_vowels(word),
            'palindrome': is_palindrome(word)
        }
    
    return result

# Test the function
text = "level python noon code"
analysis = analyze_words(text)
for word, info in analysis.items():
    print(f"\n{word}:")
    for key, value in info.items():
        print(f"  {key}: {value}")
```

**Explanation:**
- We define helper functions for vowel counting and palindrome checking
- The main function creates a dictionary comprehension with nested dictionaries
- Each word is analyzed only once, making it efficient for large inputs
</div>
